/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

void delay_ms(uint32_t ms);
void led_init(void);
void button_init(void);
void uart2_init(void);
void dma1_init(void);

volatile extern const uint8_t tx_data;
volatile extern const uint32_t tx_length;
volatile uint8_t rx_data[20];
volatile const uint32_t rx_length = sizeof(rx_data);
volatile uint8_t i_tx = 0;
volatile uint8_t i_rx = 0;

int main(void)
{
	// FPU Init
	*CPACR |= (0xf << 20);

	led_init();

	button_init();

	dma1_init();

	uart2_init();

	for(;;)
	{
		//		delay_ms(2000);
	}
}

void delay_ms(uint32_t ms)
{
	for(long int i=0; i<(ms*1600); i++);
}

void led_init(void)
{
	*RCC_AHB1ENR |= (1 << 2);

	*GPIOC_MODER |= (1 << 26);

	*GPIOC_ODR |= (1 << 13);
}

void button_init(void)
{
	*RCC_AHB1ENR |= (1 << 1);

	*RCC_APB2ENR |= (1 << 14);
	*SYSCFG_EXTICR3 |= (1 << 8);

	*EXTI_FTSR |= (1 << 10);
	*EXTI_RTSR &= ~(1 << 10);
	*EXTI_IMR |= (1 << 10);

	*NVIC_IPR10 |= ((3 << 4) << 0);
	__asm volatile("":::"memory");
	*NVIC_ISER1 |= (1 << 8);
	__asm volatile("":::"memory");
}

void dma1_init(void)
{
	*RCC_AHB1ENR |= (1 << 21);

	*DMA1_S5CR |= ((4 << 25) | (1 << 10) | (1 << 8) | (1 << 4));
	*DMA1_S5CR &= ~((3 << 13) | (3 << 11));
	*DMA1_S5NDTR = rx_length;
	*DMA1_S5PAR = (uint32_t)UART2_DR;
	*DMA1_S5M0AR = (uint32_t)&rx_data[0];
	*DMA1_S5FCR |= ((1 << 2) | (3 << 0));

	*DMA1_S6CR |= ((4 << 25) | (1 << 10) | (1 << 6) | (1 << 4));
	*DMA1_S6CR &= ~((3 << 13) | (3 << 11));
	*DMA1_S6NDTR = tx_length;
	*DMA1_S6PAR = (uint32_t)UART2_DR;
	*DMA1_S6M0AR = (uint32_t)&tx_data;
	*DMA1_S6FCR |= ((1 << 2) | (3 << 0));

	*DMA1_S5CR |= (1 << 0);

	*NVIC_IPR4 |= ((5 << 4) << 0);
	__asm volatile("":::"memory");
	*NVIC_ISER0 |= (1 << 16);
	__asm volatile("":::"memory");

	*NVIC_IPR4 |= ((5 << 4) << 8);
	__asm volatile("":::"memory");
	*NVIC_ISER0 |= (1 << 17);
	__asm volatile("":::"memory");
}

void uart2_init(void)
{
	*RCC_AHB1ENR |= (1 << 0);

	*GPIOA_MODER |= (10 << 4);
	*GPIOA_OSPEEDR |= (15 << 4);
	*GPIOA_AFRL |= (0x77 << 8);

	*RCC_APB1ENR |= (1 << 17);

	// Baudrate -> 9600 = 0x0683, 115200 = 8B
	*UART2_BRR = 0x8B;
	*UART2_SR &= ~(1 << 6);
	//	*UART2_CR1 |= ((1 << 6) | (1 << 5));
	*UART2_CR3 |= ((1 << 7) | (1 << 6));

	*UART2_CR1 |= (1 << 13);

	*UART2_CR1 |= (1 << 2);
	*UART2_CR1 |= (1 << 3);

	//	*NVIC_IPR9 |= ((5 << 4) << 16);
	//	__asm volatile("":::"memory");
	//	*NVIC_ISER1 |= (1 << 6);
	//	__asm volatile("":::"memory");
}

void EXTI15_10_IRQHandler(void)
{
	//	*GPIOC_ODR ^= (1 << 13);
	//	uint32_t sr = *UART2_SR;
	//	UNUSED(sr);
	//	*UART2_DR = *(&tx_data + i_tx++);
	//	*UART2_CR1 |= (1 << 3);
	//	i_tx %= tx_length;
	//	if((*DMA1_S6CR & 0x01) == 0x00)
	//	*DMA1_S5CR |= (1 << 0);
	*DMA1_S6CR |= (1 << 0);

	*EXTI_PR |= (1 << 10);
}

void USART2_IRQHandler(void)
{
	//	uint32_t sr = *UART2_SR;
	//	if((sr & 0x40) != 0x00)
	//	{
	//		*UART2_SR &= ~(1 << 6);
	//		*GPIOC_ODR ^= (1 << 13);
	//	}
	//	else if((sr & 0x20) != 0x00 || (sr & 0x08) != 0x00)
	//	{
	//		rx_data[i_rx++] = *UART2_DR;
	//		i_rx %= rx_length;
	//		*GPIOC_ODR ^= (1 << 13);
	//	}
}

void DMA1_Stream5_IRQHandler(void)
{
	*GPIOC_ODR ^= (1 << 13);

	*DMA1_HIFCR |= (1 << 11);
}

void DMA1_Stream6_IRQHandler(void)
{
	*GPIOC_ODR ^= (1 << 13);

	*DMA1_HIFCR |= (1 << 21);
}
